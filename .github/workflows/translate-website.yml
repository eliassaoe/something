name: Translate Modified HTML File
on:
  workflow_dispatch:
  push:
    branches:
      - main
    paths:
      - '*.html'
permissions:
  contents: write
  pull-requests: write
jobs:
  translate-website:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 2
      
      - name: Get last modified file
        id: get_file
        run: |
          MODIFIED_FILE=$(git diff --name-only HEAD^ HEAD | grep '\.html$' | head -n 1)
          if [ -n "$MODIFIED_FILE" ]; then
            echo "file=$MODIFIED_FILE" >> $GITHUB_OUTPUT
            echo "Le fichier HTML modifi√© est: $MODIFIED_FILE"
          else
            echo "Aucun fichier HTML modifi√© dans le dernier commit."
            exit 0
          fi
      
      - name: Setup Node.js
        if: steps.get_file.outputs.file != ''
        uses: actions/setup-node@v3
        with:
          node-version: '18'
      
      - name: Install dependencies
        if: steps.get_file.outputs.file != ''
        run: npm install axios
      
      - name: Create translation script
        if: steps.get_file.outputs.file != ''
        run: |
          cat > translate-file.js <<'EOL'
          const fs = require('fs');
          const path = require('path');
          const axios = require('axios');
          
          // Le fichier √† traduire (pass√© comme argument)
          const fileToTranslate = process.argv[2];
          
          // Configuration
          const API_KEY = 'AIzaSyC3m8ihaQF54PqboogrbwTjAxgtBtaNbQI';
          const TARGET_LANGUAGES = ['fr', 'ar', 'pt', 'es', 'nl', 'de'];
          const BASE_URL = 'https://unlimited-leads.online';
          
          // Fonction pour traduire du texte
          async function translateText(text, targetLanguage) {
            if (!text || !text.trim()) return text;
            
            await new Promise(resolve => setTimeout(resolve, 100));
            
            try {
              const response = await axios({
                method: 'post',
                url: `https://translation.googleapis.com/language/translate/v2?key=${API_KEY}`,
                data: {
                  q: text,
                  target: targetLanguage,
                  format: 'html'
                }
              });
              
              return response.data.data.translations[0].translatedText;
            } catch (error) {
              console.error(`Erreur de traduction: ${error.message}`);
              return text;
            }
          }
          
          // Fonction pour traduire le contenu HTML
          async function translateHtml(html, targetLanguage, originalFilename) {
            try {
              // 1. Traduire le titre
              const titleRegex = /<title>(.*?)<\/title>/i;
              const titleMatch = html.match(titleRegex);
              
              if (titleMatch && titleMatch[1]) {
                const translatedTitle = await translateText(titleMatch[1], targetLanguage);
                html = html.replace(titleMatch[0], `<title>${translatedTitle}</title>`);
              }
              
              // 2. Traduire les meta descriptions
              const metaRegex = /<meta\s+(?:name|property)=["'](description|keywords|og:title|og:description)["']\s+content=["'](.*?)["']/gi;
              let metaMatch;
              
              while ((metaMatch = metaRegex.exec(html)) !== null) {
                const [fullMatch, metaName, metaContent] = metaMatch;
                const translatedContent = await translateText(metaContent, targetLanguage);
                html = html.replace(fullMatch, fullMatch.replace(metaContent, translatedContent));
              }
              
              // 3. D√©finir la langue du document
              html = html.replace(/<html\b([^>]*)>/i, `<html$1 lang="${targetLanguage}">`);
              
              // 4. Ajouter des balises hreflang
              let hreflangTags = '';
              for (const lang of TARGET_LANGUAGES) {
                hreflangTags += `<link rel="alternate" hreflang="${lang}" href="${BASE_URL}/${lang}/${originalFilename}" />\n    `;
              }
              
              const xDefaultTag = `<link rel="alternate" hreflang="x-default" href="${BASE_URL}/${originalFilename}" />`;
              html = html.replace(/<\/head>/i, `    ${xDefaultTag}\n    ${hreflangTags}</head>`);
              
              // 5. Traduire les blocs de texte visibles
              const textBlocks = [
                { regex: /<p\b[^>]*>(.*?)<\/p>/gis, tag: 'p' },
                { regex: /<h1\b[^>]*>(.*?)<\/h1>/gis, tag: 'h1' },
                { regex: /<h2\b[^>]*>(.*?)<\/h2>/gis, tag: 'h2' },
                { regex: /<h3\b[^>]*>(.*?)<\/h3>/gis, tag: 'h3' },
                { regex: /<h4\b[^>]*>(.*?)<\/h4>/gis, tag: 'h4' },
                { regex: /<span\b[^>]*>((?!<span|<div|<p|<h).+?)<\/span>/gis, tag: 'span' },
                { regex: /<a\b[^>]*>((?!<div|<p|<h).+?)<\/a>/gis, tag: 'a' },
                { regex: /<li\b[^>]*>((?!<div|<p|<h).+?)<\/li>/gis, tag: 'li' },
                { regex: /<button\b[^>]*>((?!<div|<p|<h).+?)<\/button>/gis, tag: 'button' },
                { regex: /<label\b[^>]*>((?!<div|<p|<h).+?)<\/label>/gis, tag: 'label' }
              ];
              
              for (const block of textBlocks) {
                let match;
                while ((match = block.regex.exec(html)) !== null) {
                  const fullMatch = match[0];
                  const textContent = match[1];
                  
                  // Ignorer les contenus vides ou scripts
                  if (!textContent || !textContent.trim() || /<script|<style/i.test(textContent)) {
                    continue;
                  }
                  
                  // Ignorer les contenus avec balises HTML compl√®tes
                  if (textContent.includes('</') && textContent.includes('<')) {
                    continue;
                  }
                  
                  try {
                    const translatedContent = await translateText(textContent, targetLanguage);
                    if (translatedContent && translatedContent !== textContent) {
                      html = html.replace(fullMatch, fullMatch.replace(textContent, translatedContent));
                    }
                  } catch (e) {
                    console.log(`√âchec de traduction pour un texte`);
                  }
                }
              }
              
              return html;
            } catch (error) {
              console.error(`Erreur lors de la traduction HTML: ${error.message}`);
              return html;
            }
          }
          
          // Fonction principale
          async function translateFile() {
            if (!fileToTranslate || !fs.existsSync(fileToTranslate)) {
              console.error(`‚ùå Le fichier ${fileToTranslate} n'existe pas.`);
              process.exit(1);
            }
            
            console.log(`üîÑ Traduction du fichier: ${fileToTranslate}`);
            
            // Lire le contenu du fichier
            const fileContent = fs.readFileSync(fileToTranslate, 'utf8');
            
            // Cr√©er les dossiers de langue s'ils n'existent pas
            for (const lang of TARGET_LANGUAGES) {
              const langDir = `./${lang}`;
              if (!fs.existsSync(langDir)) {
                fs.mkdirSync(langDir, { recursive: true });
                console.log(`üìÅ Dossier cr√©√©: ${langDir}`);
              }
            }
            
            // Traduire le fichier dans chaque langue
            for (const lang of TARGET_LANGUAGES) {
              console.log(`\nüåç Traduction en ${lang}...`);
              
              try {
                // Traduire le contenu
                const translatedContent = await translateHtml(fileContent, lang, fileToTranslate);
                
                // Sauvegarder le fichier traduit
                const outputPath = `./${lang}/${fileToTranslate}`;
                fs.writeFileSync(outputPath, translatedContent);
                console.log(`‚úÖ Fichier traduit: ${outputPath}`);
              } catch (error) {
                console.error(`‚ùå Erreur lors de la traduction en ${lang}: ${error.message}`);
              }
            }
            
            console.log("\nüéâ Traduction termin√©e!");
          }
          
          // Ex√©cuter la fonction principale
          translateFile().catch(error => {
            console.error("‚ùå Erreur g√©n√©rale:", error.message);
            process.exit(1);
          });
          EOL
      
      - name: Execute translation script
        if: steps.get_file.outputs.file != ''
        run: node translate-file.js "${{ steps.get_file.outputs.file }}"
      
      - name: Clean up node_modules
        if: steps.get_file.outputs.file != ''
        run: rm -rf node_modules
      
      - name: Create Pull Request
        uses: peter-evans/create-pull-request@v5
        with:
          token: ${{ github.token }}
          commit-message: "üåê Traduction de ${{ steps.get_file.outputs.file }}"
          title: "Traduction de ${{ steps.get_file.outputs.file }}"
          body: |
            Traduction automatique de ${{ steps.get_file.outputs.file }} en:
            - Fran√ßais
            - Arabe
            - Portugais
            - Espagnol
            - N√©erlandais
            - Allemand
          branch: "translate-html"
          base: main
