name: Translate Modified HTML File
on:
  workflow_dispatch:
  push:
    branches:
      - main
    paths:
      - '*.html'
permissions:
  contents: write
  pull-requests: write
jobs:
  translate-website:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 2
      
      - name: Get last modified file
        id: get_file
        run: |
          MODIFIED_FILE=$(git diff --name-only HEAD^ HEAD | grep '\.html$' | head -n 1)
          if [ -n "$MODIFIED_FILE" ]; then
            echo "file=$MODIFIED_FILE" >> $GITHUB_OUTPUT
            echo "Le fichier HTML modifi√© est: $MODIFIED_FILE"
          else
            echo "Aucun fichier HTML modifi√© dans le dernier commit."
            exit 0
          fi
      
      - name: Generate branch name
        if: steps.get_file.outputs.file != ''
        id: branch_name
        run: |
          BRANCH_NAME="translate-$(echo "${{ steps.get_file.outputs.file }}" | sed 's/\./-/g')"
          echo "name=$BRANCH_NAME" >> $GITHUB_OUTPUT
      
      - name: Setup Node.js
        if: steps.get_file.outputs.file != ''
        uses: actions/setup-node@v3
        with:
          node-version: '18'
      
      - name: Install dependencies
        if: steps.get_file.outputs.file != ''
        run: npm install axios slugify
      
      - name: Create translation script
        if: steps.get_file.outputs.file != ''
        run: |
          cat > translate-file.js <<'EOL'
          const fs = require('fs');
          const path = require('path');
          const axios = require('axios');
          const slugify = require('slugify');
          
          // Le fichier √† traduire (pass√© comme argument)
          const fileToTranslate = process.argv[2];
          
          // Configuration
          const API_KEY = 'AIzaSyC3m8ihaQF54PqboogrbwTjAxgtBtaNbQI';
          const TARGET_LANGUAGES = ['fr', 'ar', 'pt', 'es', 'nl', 'de'];
          const BASE_URL = 'https://unlimited-leads.online';
          
          // Fonction pour traduire du texte
          async function translateText(text, targetLanguage) {
            if (!text || !text.trim()) return text;
            
            // Pause pour √©viter de surcharger l'API
            await new Promise(resolve => setTimeout(resolve, 100));
            
            try {
              const response = await axios({
                method: 'post',
                url: `https://translation.googleapis.com/language/translate/v2?key=${API_KEY}`,
                data: {
                  q: text,
                  target: targetLanguage,
                  format: 'html'
                }
              });
              
              return response.data.data.translations[0].translatedText;
            } catch (error) {
              console.error(`Erreur de traduction: ${error.message}`);
              return text;
            }
          }
          
          // Fonction pour traduire et slugifier un nom de fichier
          async function translateAndSlugifyFilename(filename, targetLanguage) {
            // Garder index.html tel quel
            if (filename === 'index.html') {
              return 'index.html';
            }
            
            const extension = path.extname(filename);
            const nameWithoutExt = path.basename(filename, extension);
            const nameWithSpaces = nameWithoutExt.replace(/-/g, ' ');
            
            try {
              const translatedName = await translateText(nameWithSpaces, targetLanguage);
              const sluggedName = slugify(translatedName, {
                lower: true,
                strict: true
              });
              
              return sluggedName + extension;
            } catch (error) {
              console.error(`Erreur de traduction du nom: ${error.message}`);
              return filename;
            }
          }
          
          // Fonction pour traduire le contenu HTML
          async function translateHtml(html, targetLanguage, originalFilename, translatedFilename) {
            try {
              // 1. Traduire le titre
              const titleRegex = /<title>(.*?)<\/title>/i;
              const titleMatch = html.match(titleRegex);
              
              if (titleMatch && titleMatch[1]) {
                const translatedTitle = await translateText(titleMatch[1], targetLanguage);
                html = html.replace(titleMatch[0], `<title>${translatedTitle}</title>`);
              }
              
              // 2. Traduire les meta descriptions
              const metaRegex = /<meta\s+(?:name|property)=["'](description|keywords|og:title|og:description)["']\s+content=["'](.*?)["']/gi;
              let metaMatch;
              
              while ((metaMatch = metaRegex.exec(html)) !== null) {
                const [fullMatch, metaName, metaContent] = metaMatch;
                const translatedContent = await translateText(metaContent, targetLanguage);
                html = html.replace(fullMatch, fullMatch.replace(metaContent, translatedContent));
              }
              
              // 3. D√©finir la langue du document
              html = html.replace(/<html\b([^>]*)>/i, `<html$1 lang="${targetLanguage}">`);
              
              // 4. Ajouter des balises hreflang
              let hreflangTags = '';
              for (const lang of TARGET_LANGUAGES) {
                const langFilename = lang === targetLanguage ? 
                  translatedFilename : 
                  await translateAndSlugifyFilename(originalFilename, lang);
                
                hreflangTags += `<link rel="alternate" hreflang="${lang}" href="${BASE_URL}/${lang}/${langFilename}" />\n    `;
              }
              
              const xDefaultTag = `<link rel="alternate" hreflang="x-default" href="${BASE_URL}/${originalFilename}" />`;
              html = html.replace(/<\/head>/i, `    ${xDefaultTag}\n    ${hreflangTags}</head>`);
              
              // 5. Traduire les blocs de texte visibles
              const textBlocks = [
                { regex: /<p\b[^>]*>(.*?)<\/p>/gis, tag: 'p' },
                { regex: /<h[1-6]\b[^>]*>(.*?)<\/h[1-6]>/gis, tag: 'h' },
                { regex: /<span\b[^>]*>((?!<span|<div|<p|<h).+?)<\/span>/gis, tag: 'span' },
                { regex: /<div\b[^>]*>((?!<div|<p|<h).+?)<\/div>/gis, tag: 'div' },
                { regex: /<a\b[^>]*>((?!<div|<p|<h).+?)<\/a>/gis, tag: 'a' },
                { regex: /<li\b[^>]*>((?!<div|<p|<h).+?)<\/li>/gis, tag: 'li' },
                { regex: /<button\b[^>]*>((?!<div|<p|<h).+?)<\/button>/gis, tag: 'button' },
                { regex: /<label\b[^>]*>((?!<div|<p|<h).+?)<\/label>/gis, tag: 'label' },
                { regex: /<footer\b[^>]*>(.*?)<\/footer>/gis, tag: 'footer' }
              ];
              
              for (const block of textBlocks) {
                let match;
                while ((match = block.regex.exec(html)) !== null) {
                  const fullMatch = match[0];
                  const textContent = match[1];
                  
                  // Ignorer les contenus vides ou scripts
                  if (!textContent || !textContent.trim() || /<script|<style/i.test(textContent)) {
                    continue;
                  }
                  
                  // Ignorer les contenus avec balises HTML compl√®tes
                  if (textContent.includes('</') && textContent.includes('<')) {
                    continue;
                  }
                  
                  try {
                    const translatedContent = await translateText(textContent, targetLanguage);
                    if (translatedContent && translatedContent !== textContent) {
                      html = html.replace(fullMatch, fullMatch.replace(textContent, translatedContent));
                    }
                  } catch (e) {
                    console.log(`√âchec de traduction pour un texte`);
                  }
                }
              }
              
              // 6. Mettre √† jour les liens internes
              const linkRegex = /<a\b[^>]*href=["']([^"']+\.html)["'][^>]*>/gi;
              let linkMatch;
              
              while ((linkMatch = linkRegex.exec(html)) !== null) {
                const [fullMatch, href] = linkMatch;
                
                // Ignorer les liens externes
                if (href.startsWith('http') || href.startsWith('//') || href.startsWith('#')) {
                  continue;
                }
                
                const linkedFilename = path.basename(href);
                try {
                  const translatedLinkedFilename = await translateAndSlugifyFilename(linkedFilename, targetLanguage);
                  const newHref = href.replace(linkedFilename, translatedLinkedFilename);
                  html = html.replace(fullMatch, fullMatch.replace(href, `/${targetLanguage}/${newHref}`));
                } catch (e) {
                  console.error(`Erreur lors de la traduction de lien`);
                }
              }
              
              return html;
            } catch (error) {
              console.error(`Erreur lors de la traduction HTML: ${error.message}`);
              return html;
            }
          }
          
          // Fonction principale
          async function translateFile() {
            if (!fileToTranslate || !fs.existsSync(fileToTranslate)) {
              console.error(`‚ùå Le fichier ${fileToTranslate} n'existe pas.`);
              process.exit(1);
            }
            
            console.log(`üîÑ Traduction du fichier: ${fileToTranslate}`);
            
            // Lire le contenu du fichier
            const fileContent = fs.readFileSync(fileToTranslate, 'utf8');
            
            // Cr√©er les dossiers de langue s'ils n'existent pas
            for (const lang of TARGET_LANGUAGES) {
              const langDir = `./${lang}`;
              if (!fs.existsSync(langDir)) {
                fs.mkdirSync(langDir, { recursive: true });
                console.log(`üìÅ Dossier cr√©√©: ${langDir}`);
              }
            }
            
            // Traduire le fichier dans chaque langue
            const translatedFiles = {};
            
            for (const lang of TARGET_LANGUAGES) {
              console.log(`\nüåç Traduction en ${lang}...`);
              
              try {
                // Traduire le nom du fichier
                const translatedFilename = await translateAndSlugifyFilename(fileToTranslate, lang);
                console.log(`üìù Nom traduit: ${fileToTranslate} ‚Üí ${translatedFilename}`);
                
                // Traduire le contenu
                const translatedContent = await translateHtml(fileContent, lang, fileToTranslate, translatedFilename);
                
                // Sauvegarder le fichier traduit
                const outputPath = `./${lang}/${translatedFilename}`;
                fs.writeFileSync(outputPath, translatedContent);
                console.log(`‚úÖ Fichier traduit: ${outputPath}`);
                
                // Enregistrer le nom traduit
                translatedFiles[lang] = translatedFilename;
              } catch (error) {
                console.error(`‚ùå Erreur lors de la traduction en ${lang}: ${error.message}`);
              }
            }
            
            console.log("\nüéâ Traduction termin√©e!");
          }
          
          // Ex√©cuter la fonction principale
          translateFile().catch(error => {
            console.error("‚ùå Erreur g√©n√©rale:", error.message);
            process.exit(1);
          });
          EOL
      
      - name: Execute translation script
        if: steps.get_file.outputs.file != ''
        run: node translate-file.js "${{ steps.get_file.outputs.file }}"
      
      - name: Clean up node_modules
        if: steps.get_file.outputs.file != ''
        run: rm -rf node_modules
      
      - name: Create Pull Request
        if: steps.get_file.outputs.file != ''
        uses: peter-evans/create-pull-request@v5
        with:
          commit-message: "üåê Traduction de ${{ steps.get_file.outputs.file }}"
          title: "Traduction de ${{ steps.get_file.outputs.file }}"
          body: |
            Traduction automatique de ${{ steps.get_file.outputs.file }} en:
            - Fran√ßais
            - Arabe
            - Portugais
            - Espagnol
            - N√©erlandais
            - Allemand
          branch: ${{ steps.branch_name.outputs.name }}
          base: main
          delete-branch: true
