name: Translate Modified HTML File
on:
  workflow_dispatch:
  push:
    branches:
      - main
    paths:
      - '*.html'
permissions:
  contents: write
  pull-requests: write
jobs:
  translate-website:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        language: [fr, ar, es, pt, de, nl]
        language_name: [francais, arabic, espanol, portugais, allemand, neerlandais]
    steps:
      - name: Checkout repository on language branch
        uses: actions/checkout@v3
        with:
          ref: ${{ matrix.language_name }}
          fetch-depth: 0
        continue-on-error: true
        
      - name: Create language branch if it doesn't exist
        if: ${{ failure() }}
        run: |
          git fetch origin main
          git checkout -b ${{ matrix.language_name }} origin/main
          git push -u origin ${{ matrix.language_name }}
      
      - name: Get latest repository state
        run: |
          git fetch origin main
      
      - name: Get last modified file from main
        run: |
          MODIFIED_FILE=$(git diff --name-only origin/main...HEAD -- '*.html' | head -n 1)
          if [ -z "$MODIFIED_FILE" ]; then
            # Get the most recent HTML file modified in main
            git checkout origin/main -- '*.html'
            MODIFIED_FILE=$(find . -maxdepth 1 -name "*.html" -type f | sort -r | head -n 1)
            MODIFIED_FILE=${MODIFIED_FILE#./}
          fi
          echo "file=$MODIFIED_FILE" >> $GITHUB_OUTPUT
          echo "Le fichier HTML modifi√© est: $MODIFIED_FILE"
        id: get_file
      
      - name: Setup Node.js
        if: steps.get_file.outputs.file != ''
        uses: actions/setup-node@v3
        with:
          node-version: '18'
      
      - name: Install dependencies
        if: steps.get_file.outputs.file != ''
        run: npm install axios
      
      - name: Create translation script
        if: steps.get_file.outputs.file != ''
        run: |
          cat > translate-file.js <<'EOL'
          const fs = require('fs');
          const path = require('path');
          const axios = require('axios');
          
          // Le fichier √† traduire (pass√© comme argument)
          const fileToTranslate = process.argv[2];
          // La langue cible (pass√©e comme deuxi√®me argument)
          const targetLanguage = process.argv[3];
          
          // Configuration
          const API_KEY = 'AIzaSyC3m8ihaQF54PqboogrbwTjAxgtBtaNbQI';
          const TARGET_LANGUAGES = ['fr', 'ar', 'pt', 'es', 'nl', 'de'];
          const BASE_URL = 'https://unlimited-leads.online';
          
          // Fonction pour traduire du texte
          async function translateText(text, targetLanguage) {
            if (!text || !text.trim()) return text;
            
            await new Promise(resolve => setTimeout(resolve, 100));
            
            try {
              const response = await axios({
                method: 'post',
                url: `https://translation.googleapis.com/language/translate/v2?key=${API_KEY}`,
                data: {
                  q: text,
                  target: targetLanguage,
                  format: 'html'
                }
              });
              
              return response.data.data.translations[0].translatedText;
            } catch (error) {
              console.error(`Erreur de traduction: ${error.message}`);
              return text;
            }
          }
          
          // Fonction pour traduire le contenu HTML
          async function translateHtml(html, targetLanguage, originalFilename) {
            try {
              // 1. Traduire le titre
              const titleRegex = /<title>(.*?)<\/title>/i;
              const titleMatch = html.match(titleRegex);
              
              if (titleMatch && titleMatch[1]) {
                const translatedTitle = await translateText(titleMatch[1], targetLanguage);
                html = html.replace(titleMatch[0], `<title>${translatedTitle}</title>`);
              }
              
              // 2. Traduire les meta descriptions
              const metaRegex = /<meta\s+(?:name|property)=["'](description|keywords|og:title|og:description)["']\s+content=["'](.*?)["']/gi;
              let metaMatch;
              
              while ((metaMatch = metaRegex.exec(html)) !== null) {
                const [fullMatch, metaName, metaContent] = metaMatch;
                const translatedContent = await translateText(metaContent, targetLanguage);
                html = html.replace(fullMatch, fullMatch.replace(metaContent, translatedContent));
              }
              
              // 3. D√©finir la langue du document
              html = html.replace(/<html\b([^>]*)>/i, `<html$1 lang="${targetLanguage}">`);
              
              // 4. Ajouter des balises hreflang
              let hreflangTags = '';
              for (const lang of TARGET_LANGUAGES) {
                hreflangTags += `<link rel="alternate" hreflang="${lang}" href="${BASE_URL}/${lang}/${originalFilename}" />\n    `;
              }
              
              const xDefaultTag = `<link rel="alternate" hreflang="x-default" href="${BASE_URL}/${originalFilename}" />`;
              html = html.replace(/<\/head>/i, `    ${xDefaultTag}\n    ${hreflangTags}</head>`);
              
              // 5. Traduire les blocs de texte visibles
              const textBlocks = [
                { regex: /<p\b[^>]*>(.*?)<\/p>/gis, tag: 'p' },
                { regex: /<h1\b[^>]*>(.*?)<\/h1>/gis, tag: 'h1' },
                { regex: /<h2\b[^>]*>(.*?)<\/h2>/gis, tag: 'h2' },
                { regex: /<h3\b[^>]*>(.*?)<\/h3>/gis, tag: 'h3' },
                { regex: /<h4\b[^>]*>(.*?)<\/h4>/gis, tag: 'h4' },
                { regex: /<span\b[^>]*>((?!<span|<div|<p|<h).+?)<\/span>/gis, tag: 'span' },
                { regex: /<a\b[^>]*>((?!<div|<p|<h).+?)<\/a>/gis, tag: 'a' },
                { regex: /<li\b[^>]*>((?!<div|<p|<h).+?)<\/li>/gis, tag: 'li' },
                { regex: /<button\b[^>]*>((?!<div|<p|<h).+?)<\/button>/gis, tag: 'button' },
                { regex: /<label\b[^>]*>((?!<div|<p|<h).+?)<\/label>/gis, tag: 'label' }
              ];
              
              for (const block of textBlocks) {
                let match;
                while ((match = block.regex.exec(html)) !== null) {
                  const fullMatch = match[0];
                  const textContent = match[1];
                  
                  // Ignorer les contenus vides ou scripts
                  if (!textContent || !textContent.trim() || /<script|<style/i.test(textContent)) {
                    continue;
                  }
                  
                  // Ignorer les contenus avec balises HTML compl√®tes
                  if (textContent.includes('</') && textContent.includes('<')) {
                    continue;
                  }
                  
                  try {
                    const translatedContent = await translateText(textContent, targetLanguage);
                    if (translatedContent && translatedContent !== textContent) {
                      html = html.replace(fullMatch, fullMatch.replace(textContent, translatedContent));
                    }
                  } catch (e) {
                    console.log(`√âchec de traduction pour un texte`);
                  }
                }
              }
              
              return html;
            } catch (error) {
              console.error(`Erreur lors de la traduction HTML: ${error.message}`);
              return html;
            }
          }
          
          // Fonction principale
          async function translateFile() {
            if (!fileToTranslate || !fs.existsSync(fileToTranslate)) {
              console.error(`‚ùå Le fichier ${fileToTranslate} n'existe pas.`);
              process.exit(1);
            }
            
            console.log(`üîÑ Traduction du fichier: ${fileToTranslate} en ${targetLanguage}`);
            
            // Lire le contenu du fichier
            const fileContent = fs.readFileSync(fileToTranslate, 'utf8');
            
            // Cr√©er le dossier de langue s'il n'existe pas
            const langDir = `./${targetLanguage}`;
            if (!fs.existsSync(langDir)) {
              fs.mkdirSync(langDir, { recursive: true });
              console.log(`üìÅ Dossier cr√©√©: ${langDir}`);
            }
            
            // Traduire le contenu
            const translatedContent = await translateHtml(fileContent, targetLanguage, fileToTranslate);
            
            // Sauvegarder le fichier traduit
            const outputPath = `./${targetLanguage}/${fileToTranslate}`;
            fs.writeFileSync(outputPath, translatedContent);
            console.log(`‚úÖ Fichier traduit: ${outputPath}`);
          }
          
          // Ex√©cuter la fonction principale
          translateFile().catch(error => {
            console.error("‚ùå Erreur g√©n√©rale:", error.message);
            process.exit(1);
          });
          EOL
      
      - name: Execute translation script for single language
        if: steps.get_file.outputs.file != ''
        run: node translate-file.js "${{ steps.get_file.outputs.file }}" "${{ matrix.language }}"
      
      - name: Clean up node_modules
        if: steps.get_file.outputs.file != ''
        run: rm -rf node_modules
      
      - name: Commit and push changes to language branch
        if: steps.get_file.outputs.file != ''
        run: |
          mkdir -p ${{ matrix.language }}
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add .
          git commit -m "üåê Traduction de ${{ steps.get_file.outputs.file }} en ${{ matrix.language }}"
          git push origin ${{ matrix.language_name }}
