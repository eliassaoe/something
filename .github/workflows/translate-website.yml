name: Translate Last Modified HTML
on:
  workflow_dispatch:  # D√©clenchement manuel
  push:
    branches:
      - main
    paths:
      - '*.html'      # Ne se d√©clenche que lorsque des fichiers HTML sont modifi√©s
permissions:
  contents: write
jobs:
  translate-website:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          
      - name: Install dependencies
        run: npm install axios slugify
        
      - name: Create translation script
        run: |
          cat > translate-last-modified.js <<'EOL'
          const fs = require('fs');
          const path = require('path');
          const axios = require('axios');
          const slugify = require('slugify');
          
          // Configuration
          const API_KEY = 'AIzaSyC3m8ihaQF54PqboogrbwTjAxgtBtaNbQI';
          const TARGET_LANGUAGES = ['fr', 'ar', 'pt', 'es', 'nl', 'de'];
          const BASE_URL = 'https://unlimited-leads.online';
          
          // Fichier de journal des traductions
          const TRANSLATION_LOG_FILE = '.translation-log.json';
          
          // Trouver le fichier HTML le plus r√©cemment modifi√©
          function findLastModifiedHtmlFile() {
            const htmlFiles = fs.readdirSync('./').filter(file => 
              file.endsWith('.html') && fs.statSync(file).isFile()
            );
            
            if (htmlFiles.length === 0) {
              return null;
            }
            
            // Lire le journal des traductions
            let translationLog = {};
            if (fs.existsSync(TRANSLATION_LOG_FILE)) {
              try {
                translationLog = JSON.parse(fs.readFileSync(TRANSLATION_LOG_FILE, 'utf8'));
              } catch (error) {
                console.error(`Erreur lors de la lecture du journal: ${error.message}`);
              }
            }
            
            // Trier les fichiers par date de modification d√©croissante
            htmlFiles.sort((a, b) => {
              const statsA = fs.statSync(a);
              const statsB = fs.statSync(b);
              return statsB.mtimeMs - statsA.mtimeMs;
            });
            
            // Trouver le premier fichier qui a √©t√© modifi√© depuis sa derni√®re traduction
            for (const file of htmlFiles) {
              const stats = fs.statSync(file);
              
              // V√©rifier si le fichier a d√©j√† √©t√© traduit
              if (!translationLog[file] || stats.mtimeMs > translationLog[file].lastModified) {
                return file;
              }
            }
            
            // Si tous les fichiers sont √† jour, retourner null
            return null;
          }
          
          // Fonction pour traduire du texte
          async function translateText(text, targetLanguage) {
            if (!text || !text.trim()) return text;
            
            // Pause pour √©viter de surcharger l'API
            await new Promise(resolve => setTimeout(resolve, 100));
            
            try {
              const response = await axios({
                method: 'post',
                url: `https://translation.googleapis.com/language/translate/v2?key=${API_KEY}`,
                data: {
                  q: text,
                  target: targetLanguage,
                  format: 'html'
                }
              });
              
              return response.data.data.translations[0].translatedText;
            } catch (error) {
              console.error(`Erreur de traduction: ${error.message}`);
              return text;
            }
          }
          
          // Fonction pour traduire et slugifier un nom de fichier
          async function translateAndSlugifyFilename(filename, targetLanguage) {
            // Garder index.html tel quel
            if (filename === 'index.html') {
              return 'index.html';
            }
            
            const extension = path.extname(filename);
            const nameWithoutExt = path.basename(filename, extension);
            const nameWithSpaces = nameWithoutExt.replace(/-/g, ' ');
            
            try {
              const translatedName = await translateText(nameWithSpaces, targetLanguage);
              const sluggedName = slugify(translatedName, {
                lower: true,
                strict: true
              });
              
              return sluggedName + extension;
            } catch (error) {
              console.error(`Erreur de traduction du nom: ${error.message}`);
              return filename;
            }
          }
          
          // Fonction pour traduire le contenu HTML
          async function translateHtml(html, targetLanguage, originalFilename, translatedFilename) {
            try {
              // 1. Traduire le titre
              const titleRegex = /<title>(.*?)<\/title>/i;
              const titleMatch = html.match(titleRegex);
              
              if (titleMatch && titleMatch[1]) {
                const translatedTitle = await translateText(titleMatch[1], targetLanguage);
                html = html.replace(titleMatch[0], `<title>${translatedTitle}</title>`);
              }
              
              // 2. Traduire les meta descriptions
              const metaRegex = /<meta\s+(?:name|property)=["'](description|keywords|og:title|og:description)["']\s+content=["'](.*?)["']/gi;
              let metaMatch;
              
              while ((metaMatch = metaRegex.exec(html)) !== null) {
                const [fullMatch, metaName, metaContent] = metaMatch;
                const translatedContent = await translateText(metaContent, targetLanguage);
                html = html.replace(fullMatch, fullMatch.replace(metaContent, translatedContent));
              }
              
              // 3. D√©finir la langue du document
              html = html.replace(/<html\b([^>]*)>/i, `<html$1 lang="${targetLanguage}">`);
              
              // 4. Ajouter des balises hreflang
              let hreflangTags = '';
              for (const lang of TARGET_LANGUAGES) {
                const langFilename = lang === targetLanguage ? 
                  translatedFilename : 
                  await translateAndSlugifyFilename(originalFilename, lang);
                
                hreflangTags += `<link rel="alternate" hreflang="${lang}" href="${BASE_URL}/${lang}/${langFilename}" />\n    `;
              }
              
              const xDefaultTag = `<link rel="alternate" hreflang="x-default" href="${BASE_URL}/${originalFilename}" />`;
              html = html.replace(/<\/head>/i, `    ${xDefaultTag}\n    ${hreflangTags}</head>`);
              
              // 5. Traduire les blocs de texte visibles
              const textBlocks = [
                { regex: /<p\b[^>]*>(.*?)<\/p>/gis, tag: 'p' },
                { regex: /<h[1-6]\b[^>]*>(.*?)<\/h[1-6]>/gis, tag: 'h' },
                { regex: /<span\b[^>]*>((?!<span|<div|<p|<h).+?)<\/span>/gis, tag: 'span' },
                { regex: /<div\b[^>]*>((?!<div|<p|<h).+?)<\/div>/gis, tag: 'div' },
                { regex: /<a\b[^>]*>((?!<div|<p|<h).+?)<\/a>/gis, tag: 'a' },
                { regex: /<li\b[^>]*>((?!<div|<p|<h).+?)<\/li>/gis, tag: 'li' },
                { regex: /<button\b[^>]*>((?!<div|<p|<h).+?)<\/button>/gis, tag: 'button' },
                { regex: /<label\b[^>]*>((?!<div|<p|<h).+?)<\/label>/gis, tag: 'label' },
                { regex: /<footer\b[^>]*>(.*?)<\/footer>/gis, tag: 'footer' }
              ];
              
              for (const block of textBlocks) {
                let match;
                while ((match = block.regex.exec(html)) !== null) {
                  const fullMatch = match[0];
                  const textContent = match[1];
                  
                  // Ignorer les contenus vides ou scripts
                  if (!textContent || !textContent.trim() || /<script|<style/i.test(textContent)) {
                    continue;
                  }
                  
                  // Ignorer les contenus avec balises HTML compl√®tes
                  if (textContent.includes('</') && textContent.includes('<')) {
                    continue;
                  }
                  
                  try {
                    const translatedContent = await translateText(textContent, targetLanguage);
                    if (translatedContent && translatedContent !== textContent) {
                      html = html.replace(fullMatch, fullMatch.replace(textContent, translatedContent));
                    }
                  } catch (e) {
                    console.log(`√âchec de traduction pour un texte`);
                  }
                }
              }
              
              // 6. Mettre √† jour les liens internes
              const linkRegex = /<a\b[^>]*href=["']([^"']+\.html)["'][^>]*>/gi;
              let linkMatch;
              
              while ((linkMatch = linkRegex.exec(html)) !== null) {
                const [fullMatch, href] = linkMatch;
                
                // Ignorer les liens externes
                if (href.startsWith('http') || href.startsWith('//') || href.startsWith('#')) {
                  continue;
                }
                
                const linkedFilename = path.basename(href);
                try {
                  const translatedLinkedFilename = await translateAndSlugifyFilename(linkedFilename, targetLanguage);
                  const newHref = href.replace(linkedFilename, translatedLinkedFilename);
                  html = html.replace(fullMatch, fullMatch.replace(href, `/${targetLanguage}/${newHref}`));
                } catch (e) {
                  console.error(`Erreur lors de la traduction de lien`);
                }
              }
              
              return html;
            } catch (error) {
              console.error(`Erreur lors de la traduction HTML: ${error.message}`);
              return html;
            }
          }
          
          // Fonction principale
          async function translateLastModified() {
            console.log("üîç Recherche du fichier HTML le plus r√©cemment modifi√©...");
            
            // Trouver le fichier HTML le plus r√©cemment modifi√©
            const fileToTranslate = findLastModifiedHtmlFile();
            
            if (!fileToTranslate) {
              console.log("‚úÖ Tous les fichiers HTML sont √† jour. Aucune traduction n√©cessaire.");
              return;
            }
            
            console.log(`üîÑ Fichier √† traduire: ${fileToTranslate}`);
            
            // Lire le contenu du fichier
            const fileContent = fs.readFileSync(fileToTranslate, 'utf8');
            
            // Cr√©er les dossiers de langue s'ils n'existent pas
            for (const lang of TARGET_LANGUAGES) {
              const langDir = `./${lang}`;
              if (!fs.existsSync(langDir)) {
                fs.mkdirSync(langDir, { recursive: true });
                console.log(`üìÅ Dossier cr√©√©: ${langDir}`);
              }
            }
            
            // Traduire le fichier dans chaque langue
            const translatedFiles = {};
            
            for (const lang of TARGET_LANGUAGES) {
              console.log(`\nüåç Traduction en ${lang}...`);
              
              try {
                // Traduire le nom du fichier
                const translatedFilename = await translateAndSlugifyFilename(fileToTranslate, lang);
                console.log(`üìù Nom traduit: ${fileToTranslate} ‚Üí ${translatedFilename}`);
                
                // Traduire le contenu
                const translatedContent = await translateHtml(fileContent, lang, fileToTranslate, translatedFilename);
                
                // Sauvegarder le fichier traduit
                const outputPath = `./${lang}/${translatedFilename}`;
                fs.writeFileSync(outputPath, translatedContent);
                console.log(`‚úÖ Fichier traduit: ${outputPath}`);
                
                // Enregistrer le nom traduit
                translatedFiles[lang] = translatedFilename;
              } catch (error) {
                console.error(`‚ùå Erreur lors de la traduction en ${lang}: ${error.message}`);
              }
            }
            
            // Mettre √† jour le journal des traductions
            let translationLog = {};
            if (fs.existsSync(TRANSLATION_LOG_FILE)) {
              try {
                translationLog = JSON.parse(fs.readFileSync(TRANSLATION_LOG_FILE, 'utf8'));
              } catch (error) {
                console.error(`Erreur lors de la lecture du journal: ${error.message}`);
              }
            }
            
            // Enregistrer les informations de traduction
            translationLog[fileToTranslate] = {
              lastModified: fs.statSync(fileToTranslate).mtimeMs,
              lastTranslated: Date.now(),
              languages: translatedFiles
            };
            
            // Sauvegarder le journal
            fs.writeFileSync(TRANSLATION_LOG_FILE, JSON.stringify(translationLog, null, 2), 'utf8');
            console.log(`üìù Journal des traductions mis √† jour pour ${fileToTranslate}`);
            
            // Mettre √† jour le sitemap
            try {
              console.log("\nüìë Mise √† jour du sitemap multilingue...");
              
              let sitemap = '<?xml version="1.0" encoding="UTF-8"?>\n';
              sitemap += '<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9"\n';
              sitemap += '        xmlns:xhtml="http://www.w3.org/1999/xhtml">\n';
              
              // Ajouter tous les fichiers HTML du journal
              for (const file in translationLog) {
                const originalUrl = `${BASE_URL}/${file}`;
                sitemap += '  <url>\n';
                sitemap += `    <loc>${originalUrl}</loc>\n`;
                sitemap += `    <xhtml:link rel="alternate" hreflang="x-default" href="${originalUrl}" />\n`;
                
                // Ajouter les alternatives pour chaque langue
                for (const lang of TARGET_LANGUAGES) {
                  const entry = translationLog[file];
                  if (entry && entry.languages && entry.languages[lang]) {
                    const translatedFilename = entry.languages[lang];
                    sitemap += `    <xhtml:link rel="alternate" hreflang="${lang}" href="${BASE_URL}/${lang}/${translatedFilename}" />\n`;
                  }
                }
                
                sitemap += `    <lastmod>${new Date().toISOString().split('T')[0]}</lastmod>\n`;
                sitemap += '  </url>\n';
              }
              
              sitemap += '</urlset>';
              
              // Sauvegarder le sitemap
              fs.writeFileSync('sitemap_multilingual.xml', sitemap);
              console.log("‚úÖ Sitemap multilingue mis √† jour: sitemap_multilingual.xml");
            } catch (error) {
              console.error(`‚ùå Erreur lors de la cr√©ation du sitemap: ${error.message}`);
            }
            
            console.log("\nüéâ Traduction termin√©e!");
          }
          
          // Ex√©cuter la fonction principale
          translateLastModified().catch(error => {
            console.error("‚ùå Erreur g√©n√©rale:", error.message);
            process.exit(1);
          });
          EOL
          
      - name: Execute translation script
        run: node translate-last-modified.js
        
      - name: Commit and push changes
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          git add .
          git commit -m "üåê Traduction de la derni√®re page modifi√©e" || echo "Pas de changements √† commiter"
          git push
