name: Translate Website with Google Translate
on:
  workflow_dispatch:  # D√©clenchement manuel uniquement
permissions:
  contents: write
jobs:
  translate-website:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          
      - name: Install dependencies
        run: npm install axios slugify
        
      - name: Create translation script
        run: |
          cat > translate-website.js <<'EOL'
          const fs = require('fs');
          const path = require('path');
          const axios = require('axios');
          const slugify = require('slugify');
          
          // Configuration - PARAM√âTRABLE COMME DEEPL ACTION
          const API_KEY = 'AIzaSyC3m8ihaQF54PqboogrbwTjAxgtBtaNbQI';
          const TARGET_LANGUAGES = ['fr', 'ar', 'pt', 'es', 'nl', 'de'];
          const SOURCE_LANGUAGE = 'en'; // La langue d'origine
          const BASE_URL = 'https://unlimited-leads.online';
          
          // D√©finitions des langues pour l'affichage
          const LANGUAGE_NAMES = {
            'fr': 'fran√ßais',
            'ar': 'arabe',
            'pt': 'portugais',
            'es': 'espagnol',
            'nl': 'n√©erlandais',
            'de': 'allemand'
          };
          
          // Fonction pour traduire du texte avec l'API Google Translate
          async function translateText(text, targetLanguage) {
            // √âviter de traduire du texte vide
            if (!text || !text.trim()) return text;
            
            // Limiter la fr√©quence des appels API pour √©viter les erreurs
            await new Promise(resolve => setTimeout(resolve, 100));
            
            try {
              const response = await axios({
                method: 'post',
                url: `https://translation.googleapis.com/language/translate/v2?key=${API_KEY}`,
                data: {
                  q: text,
                  target: targetLanguage,
                  source: SOURCE_LANGUAGE,
                  format: 'html'
                }
              });
              
              return response.data.data.translations[0].translatedText;
            } catch (error) {
              console.error(`Erreur de traduction: ${error.message}`);
              // En cas d'erreur d'API, attendre et r√©essayer une fois
              if (error.response && (error.response.status === 429 || error.response.status === 503)) {
                console.log('Trop de requ√™tes, attente de 2 secondes avant de r√©essayer...');
                await new Promise(resolve => setTimeout(resolve, 2000));
                try {
                  const retryResponse = await axios({
                    method: 'post',
                    url: `https://translation.googleapis.com/language/translate/v2?key=${API_KEY}`,
                    data: {
                      q: text,
                      target: targetLanguage,
                      source: SOURCE_LANGUAGE,
                      format: 'html'
                    }
                  });
                  return retryResponse.data.data.translations[0].translatedText;
                } catch (retryError) {
                  console.error(`√âchec de la nouvelle tentative: ${retryError.message}`);
                  return text; // Retourner le texte original
                }
              }
              return text; // Retourner le texte original
            }
          }
          
          // Fonction pour traduire et slugifier un nom de fichier
          async function translateAndSlugifyFilename(filename, targetLanguage) {
            // Si c'est index.html, on le garde tel quel
            if (filename === 'index.html') {
              return 'index.html';
            }
            
            try {
              // Extraire le nom sans extension
              const extension = path.extname(filename);
              const nameWithoutExt = path.basename(filename, extension);
              
              // Remplacer les tirets par des espaces pour une meilleure traduction
              const nameWithSpaces = nameWithoutExt.replace(/-/g, ' ');
              
              // Traduire le nom de fichier
              const translatedName = await translateText(nameWithSpaces, targetLanguage);
              
              // Slugifier le nom traduit (convertir en format URL-friendly)
              const slugConfig = {
                lower: true,      // Convertir en minuscules
                strict: true,     // Supprimer les caract√®res sp√©ciaux
                locale: targetLanguage === 'ar' ? 'ar' : 'en' // Gestion sp√©ciale pour l'arabe
              };
              
              const sluggedName = slugify(translatedName, slugConfig);
              
              // Retourner le nom complet avec extension
              return sluggedName + extension;
            } catch (error) {
              console.error(`Erreur lors de la traduction du nom de fichier: ${error.message}`);
              return filename; // En cas d'erreur, renvoyer le nom original
            }
          }
          
          // Fonction pour traduire le contenu HTML
          async function translateHtml(html, targetLanguage, originalFilename, translatedFilename) {
            try {
              // 1. Traduire le titre avec une regex simple
              const titleRegex = /<title>(.*?)<\/title>/i;
              const titleMatch = html.match(titleRegex);
              
              if (titleMatch && titleMatch[1]) {
                const translatedTitle = await translateText(titleMatch[1], targetLanguage);
                html = html.replace(titleMatch[0], `<title>${translatedTitle}</title>`);
              }
              
              // 2. Traduire les meta descriptions et keywords
              const metaRegex = /<meta\s+(?:name|property)=["'](description|keywords|og:title|og:description)["']\s+content=["'](.*?)["']/gi;
              let metaMatch;
              
              while ((metaMatch = metaRegex.exec(html)) !== null) {
                const [fullMatch, metaName, metaContent] = metaMatch;
                const translatedContent = await translateText(metaContent, targetLanguage);
                html = html.replace(fullMatch, fullMatch.replace(metaContent, translatedContent));
              }
              
              // 3. D√©finir la langue du document
              html = html.replace(/<html\b([^>]*)>/i, `<html$1 lang="${targetLanguage}">`);
              
              // 4. Ajouter des balises hreflang pour le SEO
              let hreflangTags = '';
              for (const lang of TARGET_LANGUAGES) {
                const langFilename = lang === targetLanguage ? 
                  translatedFilename : 
                  await translateAndSlugifyFilename(originalFilename, lang);
                
                hreflangTags += `<link rel="alternate" hreflang="${lang}" href="${BASE_URL}/${lang}/${langFilename}" />\n    `;
              }
              
              // Ajouter la balise hreflang x-default
              const xDefaultTag = `<link rel="alternate" hreflang="x-default" href="${BASE_URL}/${originalFilename}" />`;
              
              // Ins√©rer les balises hreflang dans la section head
              html = html.replace(/<\/head>/i, `    ${xDefaultTag}\n    ${hreflangTags}</head>`);
              
              // 5. Extraire et traduire les blocs de texte visibles
              // COMME DEEPL, on utilise une approche qui pr√©serve les balises
              const textBlocks = [
                { regex: /<p\b[^>]*>(.*?)<\/p>/gis, tag: 'p' },
                { regex: /<h[1-6]\b[^>]*>(.*?)<\/h[1-6]>/gis, tag: 'h' },
                { regex: /<span\b[^>]*>((?!<span|<div|<p|<h).+?)<\/span>/gis, tag: 'span' },
                { regex: /<div\b[^>]*>((?!<div|<p|<h).+?)<\/div>/gis, tag: 'div' },
                { regex: /<a\b[^>]*>((?!<div|<p|<h).+?)<\/a>/gis, tag: 'a' },
                { regex: /<li\b[^>]*>((?!<div|<p|<h).+?)<\/li>/gis, tag: 'li' },
                { regex: /<button\b[^>]*>((?!<div|<p|<h).+?)<\/button>/gis, tag: 'button' },
                { regex: /<label\b[^>]*>((?!<div|<p|<h).+?)<\/label>/gis, tag: 'label' },
                { regex: /<footer\b[^>]*>(.*?)<\/footer>/gis, tag: 'footer' }
              ];
              
              // Traiter chaque type de bloc de texte
              for (const block of textBlocks) {
                let match;
                while ((match = block.regex.exec(html)) !== null) {
                  const fullMatch = match[0];
                  const textContent = match[1];
                  
                  // Ne pas traduire le contenu vide ou les balises script/style
                  if (!textContent || !textContent.trim() || /<script|<style/i.test(textContent)) {
                    continue;
                  }
                  
                  // Si le contenu contient des balises HTML complexes imbriqu√©es, on saute
                  if (textContent.includes('</') && textContent.includes('<')) {
                    continue;
                  }
                  
                  try {
                    const translatedContent = await translateText(textContent, targetLanguage);
                    if (translatedContent && translatedContent !== textContent) {
                      html = html.replace(fullMatch, fullMatch.replace(textContent, translatedContent));
                    }
                  } catch (e) {
                    console.log(`√âchec de traduction pour: ${textContent.slice(0, 50)}...`);
                  }
                }
              }
              
              // 6. Mettre √† jour les liens internes pour pointer vers les versions traduites
              const linkRegex = /<a\b[^>]*href=["']([^"']+\.html)["'][^>]*>/gi;
              let linkMatch;
              
              while ((linkMatch = linkRegex.exec(html)) !== null) {
                const [fullMatch, href] = linkMatch;
                
                // Ignorer les liens externes
                if (href.startsWith('http') || href.startsWith('//') || href.startsWith('#')) {
                  continue;
                }
                
                // Traduire et slugifier le nom du fichier li√©
                const linkedFilename = path.basename(href);
                try {
                  const translatedLinkedFilename = await translateAndSlugifyFilename(linkedFilename, targetLanguage);
                  const newHref = href.replace(linkedFilename, translatedLinkedFilename);
                  html = html.replace(fullMatch, fullMatch.replace(href, `/${targetLanguage}/${newHref}`));
                } catch (e) {
                  console.error(`Erreur lors de la traduction de lien: ${e.message}`);
                }
              }
              
              return html;
            } catch (error) {
              console.error(`Erreur lors de la traduction HTML: ${error.message}`);
              return html; // Retourner le HTML original en cas d'erreur
            }
          }
          
          // Fonction principale - COMME DEEPL ACTION
          async function translateWebsite() {
            console.log("üåê D√©marrage de la traduction du site web...");
            
            // Trouver tous les fichiers HTML √† la racine
            const htmlFiles = fs.readdirSync('./').filter(file => 
              file.endsWith('.html') && fs.statSync(file).isFile()
            );
            
            if (htmlFiles.length === 0) {
              console.log("‚ö†Ô∏è Aucun fichier HTML trouv√© dans le r√©pertoire racine.");
              return;
            }
            
            console.log(`üìÑ Fichiers HTML trouv√©s (${htmlFiles.length}): ${htmlFiles.join(', ')}`);
            
            // Pour chaque langue cible, cr√©er le dossier s'il n'existe pas
            for (const lang of TARGET_LANGUAGES) {
              const langDir = `./${lang}`;
              if (!fs.existsSync(langDir)) {
                fs.mkdirSync(langDir, { recursive: true });
                console.log(`üìÅ Dossier cr√©√©: ${langDir}`);
              }
            }
            
            // Traduire chaque fichier HTML dans chaque langue
            for (const file of htmlFiles) {
              console.log(`\nüîÑ Traitement du fichier: ${file}`);
              const originalContent = fs.readFileSync(file, 'utf8');
              
              for (const lang of TARGET_LANGUAGES) {
                console.log(`\n  üåç Traduction en ${LANGUAGE_NAMES[lang]}...`);
                
                try {
                  // 1. Traduire le nom du fichier (slug)
                  const translatedFilename = await translateAndSlugifyFilename(file, lang);
                  console.log(`  üìù Nom traduit: ${file} ‚Üí ${translatedFilename}`);
                  
                  // 2. Traduire le contenu HTML
                  const translatedContent = await translateHtml(originalContent, lang, file, translatedFilename);
                  
                  // 3. Sauvegarder le fichier traduit avec le nom traduit
                  const outputPath = `./${lang}/${translatedFilename}`;
                  fs.writeFileSync(outputPath, translatedContent);
                  console.log(`  ‚úÖ Fichier traduit cr√©√©: ${outputPath}`);
                } catch (error) {
                  console.error(`  ‚ùå Erreur lors de la traduction en ${LANGUAGE_NAMES[lang]}: ${error.message}`);
                }
              }
            }
            
            // Cr√©er un sitemap.xml multilingue
            try {
              console.log("\nüìë Cr√©ation du sitemap multilingue...");
              
              let sitemap = '<?xml version="1.0" encoding="UTF-8"?>\n';
              sitemap += '<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9"\n';
              sitemap += '        xmlns:xhtml="http://www.w3.org/1999/xhtml">\n';
              
              // Pour chaque fichier HTML original
              for (const file of htmlFiles) {
                const originalUrl = `${BASE_URL}/${file}`;
                sitemap += '  <url>\n';
                sitemap += `    <loc>${originalUrl}</loc>\n`;
                sitemap += `    <xhtml:link rel="alternate" hreflang="x-default" href="${originalUrl}" />\n`;
                
                // Ajouter les alternatives pour chaque langue
                for (const lang of TARGET_LANGUAGES) {
                  const translatedFilename = await translateAndSlugifyFilename(file, lang);
                  sitemap += `    <xhtml:link rel="alternate" hreflang="${lang}" href="${BASE_URL}/${lang}/${translatedFilename}" />\n`;
                }
                
                sitemap += `    <lastmod>${new Date().toISOString().split('T')[0]}</lastmod>\n`;
                sitemap += '  </url>\n';
              }
              
              sitemap += '</urlset>';
              
              // Sauvegarder le sitemap
              fs.writeFileSync('sitemap_multilingual.xml', sitemap);
              console.log("‚úÖ Sitemap multilingue cr√©√©: sitemap_multilingual.xml");
            } catch (error) {
              console.error(`‚ùå Erreur lors de la cr√©ation du sitemap: ${error.message}`);
            }
            
            console.log("\nüéâ Traduction du site termin√©e!");
          }
          
          // Ex√©cuter la fonction principale
          translateWebsite().catch(error => {
            console.error("‚ùå Erreur g√©n√©rale:", error.message);
            process.exit(1);
          });
          EOL
          
      - name: Execute translation script
        run: node translate-website.js
        
      - name: Commit and push changes
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          git add .
          git commit -m "üåê Traduction multilingue du site web" || echo "Pas de changements √† commiter"
          git push
